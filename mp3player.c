/*==============================================================================
* Probkema Gstreamer convocatoria Ordinaria AMM 23/24
=============================================================================*/

/*=============================Compilation======================================
Con Warnings:
gcc -Wall mp3player.c -o mp3player $(pkg-config --cflags --libs gstreamer-1.0)
Sin Warnings:
gcc mp3player.c -o mp3player `pkg-config --cflags --libs gstreamer-1.0`
-----------
Compiler options (automatically generated by pkg-config):
-I/usr/include/gstreamer-0.10 --option for gcc to find the header files

Ejecución: ./mp3player [-h] [-t] -f audio.mp3
============================================================================*/

// REF: https://www.gnu.org/software/libc/manual/html_node/Parsing-Program-Arguments.html#Parsing-Program-Arguments

/* Argumentos del programa:
   -h: presenta la ayuda y termina (con estado 0)
   -t: Superpone el nombre del fichero de audio.
   -f <FICHERO_AUDIO> Nombre del fichero de audio MP3

*/


#include <stdio.h>
#include <stdlib.h>
#include <gst/gst.h>
#include <getopt.h>
#include <unistd.h>
#include <ctype.h>

// Variables globales
int texto_superpuesto = 0;

// Función para imprimir la ayuda del programa.
void help()
{
	g_print("\nAYUDA DEL PROGRAMA");
    g_print("\nComando para ejecutar el programa:\n ./mp3player [-h][-t] -f <fichero_entrada>");
	g_print("\nArgumentos del programa:\n");
	g_print("\t-h: presenta la ayuda y termina (con estado 0).\n");
	g_print("\t-t: Superpone el nombre del fichero de audio.\n");
	g_print("\t-f <FICHERO_AUDIO> Nombre del fichero de audio MP3\n");
}


// Función escuchadora de los mensajes del bus
static gboolean bus_call (GstBus *bus,	GstMessage *msg, gpointer data)
{
	GMainLoop *loop = (GMainLoop *) data;
	char *src = GST_MESSAGE_SRC_NAME(msg);
  
  	switch (GST_MESSAGE_TYPE (msg)) 
  	{

  		case GST_MESSAGE_EOS: {
	    		g_main_loop_quit (loop);
	    		break;
		}
		
		case GST_MESSAGE_ERROR: {
			gchar  *debug;
			GError *error;
    			gst_message_parse_error (msg, &error, &debug);
    			g_free (debug);
    
    			g_printerr ("..[bus].. (%s) :: Error: %s\n", src, error->message);
   			 g_error_free (error);
    			g_main_loop_quit (loop);
    			break;
		}
		default: {
  			//Para el resto de mensajes que reciba el bus, no hacemos nada
    			break;
 		}
	}	
	return TRUE;

}


// Función principal ('main')
int main(int argc, char *argv[]) 
{

	GMainLoop *loop;
// Procesamiento de los argumentos de entrada (argc, argv) 

// Número correcto de parámetros.
        if ( argc > 5 || argc < 0)  {
          help();
          return 0;
        }
// Comprobación de parámetros.  
	int c;	
	opterr = 0; // no es necesario declararla, la exporta getopt
	char *filename;		
	while ((c = getopt (argc, argv, "htf:")) != -1) {
		
	 	switch (c)
		{
			case 'h':
			{
				// ayuda	
				help();
				return 0;
			 	break;
			}
			case 't':
			{
				// Opción superponer texto activada.
				g_print("Opción superponer texto activada.\n");
				texto_superpuesto=1; 
				break;
			}
			case 'f':
			{
				// Se establece el nombre del fichero.
				filename=optarg; 
				fprintf (stderr, "Filename: %s\n", filename);
				break;
			}
	 		case '?':
			{
				/*getopt devuelve '?' si encuentra una opción desconocida
				o si falta el argumento para una opción que lo requiere
				la opción conflictiva queda almacenada en optopt*/
	 			if (isprint (optopt))
	 			{
		 			//error: opción desconocida
					fprintf (stderr, "Error: argumento `-%c' no válido\n", optopt);
					return 1; 
				}
	 			else 
	 			{
		 			fprintf (stderr, "Error: argumento `\\x%x' no válido.\n", optopt);
					return 1;
				}
				break;
			}
			default:
			{
				fprintf (stderr, "Error: argumento %d no válido\n", optind);
				return 1;
			}
	 	}
	 }
	 // getopt recoloca los argumentos no procesados al final
	 // el primero será el nombre del fichero de entrada (es correcto)	
	 // si hay algún otro: error argumento desconocido
/*		
	int index=0; 
	filename = argv[optind];
	for (index = optind+1; index < argc; index++) {		
	 	printf ("Error: argumento %s no válido\n", argv[index]);
		return 1;		
	}
*/	
	//Inicialización del framework de Gstreamer
	gst_init(&argc, &argv);  
	// Bucle principal de gestión de eventos.
	loop = g_main_loop_new (NULL, FALSE);

// Creación del pipeline y sus elementos
   	GstElement *pipeline = gst_pipeline_new ("pipeline");

	GstElement *source = gst_element_factory_make("filesrc", "fuente-fichero");
	GstElement *parse = gst_element_factory_make("mpegaudioparse", "mpegaudioparse");
    GstElement *decoder = gst_element_factory_make("mpg123audiodec", "mpg123audiodec");
    GstElement *audioconv = gst_element_factory_make("audioconvert", "audioconvert");
	GstElement *goom = gst_element_factory_make("goom", "goom");
	GstElement *videoconv = gst_element_factory_make("videoconvert", "videoconvert");
	GstElement *textoverlay = gst_element_factory_make("textoverlay", "audio-output");
	GstElement *imagesink = gst_element_factory_make("ximagesink", "ximagesink");

	//Manejo de errores en la creación de los elementos del pipeline
	if (!pipeline || !source || !parse || !decoder || !audioconv || !goom || !videoconv || !textoverlay || !imagesink 
	) 
	{
		g_printerr ("Error en la creación de elementos multimedia.\n");
		return -1;   // error multimedia
	}

//Establecimiento de propiedades de los elementos

	g_object_set (G_OBJECT (source), "location", filename, NULL);

	if (texto_superpuesto == 1){
		g_object_set (G_OBJECT (textoverlay), "text", filename, NULL);
	} 
	
	
//Creación del bus asociado al pipeline para recibir los mensajes y establecimiento de la función escuchadora.
	GstBus *bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
	gst_bus_add_watch (bus, bus_call, loop);
	gst_object_unref (bus);

// Inclusión de los elementos en el pipeline.
	gst_bin_add_many(GST_BIN(pipeline),source,parse,decoder,audioconv,goom,videoconv,textoverlay,imagesink, NULL);
	g_print ("Elementos pipeline añadidos al pipeline.\n");
	
//Enlace de los distintos elementos del pipeline
	gst_element_link_many(source,parse,decoder,audioconv,goom,videoconv,textoverlay,imagesink, NULL);
	g_print ("Elementos pipeline enlazados.\n");

// Se pone en ejecución  el pipeline
	gst_element_set_state (pipeline, GST_STATE_PLAYING);
	g_print ("Pipeline lanzado.\n");
	g_main_loop_run (loop);
	

// Paro ordenado de la ejecución del pipeline y liberación de recursos
	gst_element_set_state (pipeline, GST_STATE_NULL);
	gst_object_unref (GST_OBJECT (pipeline));
    g_print ("Pipeline finalizado.\n");
// Finalización del prograna con código de retorno.
	return 0;
}
